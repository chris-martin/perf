<meta charset="utf-8"> <link rel="stylesheet" href="https://tonyday567.github.io/other/lhs.css">
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<h1 id="perf-build-status"><a href="https://tonyday567.github.io/perf/index.html">perf</a> <a href="https://travis-ci.org/tonyday567/perf"><img src="https://travis-ci.org/tonyday567/perf.png" alt="Build Status" /></a></h1>
<p>If you want to make stuff very fast in haskell, you need to dig down below the criterion abstraction-level and start counting cycles using the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">rdtsc</a> register on x86.</p>
<p>These examples are experiments in measuring cycles (or ticks), a development of intuition about what is going on at the very fast level.</p>
<p>The interface is subject to change as intuition develops and rabbit holes explored.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -Wall #-}</span>
<span class="ot">{-# OPTIONS_GHC -fno-warn-type-defaults #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (pack, intercalate)
<span class="kw">import </span><span class="dt">Data.Text.IO</span> (writeFile)
<span class="kw">import </span><span class="dt">Formatting</span>
<span class="kw">import </span><span class="dt">Protolude</span> <span class="kw">hiding</span> ((%), intercalate)
<span class="kw">import </span><span class="dt">Data.List</span> ((!!))
<span class="kw">import </span><span class="dt">Data.TDigest</span>
<span class="kw">import </span><span class="dt">System.Random.MWC.Probability</span>
<span class="kw">import </span><span class="dt">Options.Generic</span>
<span class="kw">import qualified</span> <span class="dt">Control.Foldl</span> <span class="kw">as</span> <span class="dt">L</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">U</span>
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Storable</span> <span class="kw">as</span> <span class="dt">S</span></code></pre></div>
<p>The examples below mostly use <code>Perf.Cycles</code>. There is also a monad layer in <code>Perf</code> which has been used in <code>other/summing.lhs</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Perf</span></code></pre></div>
<p>All the imports that are needed for charts</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Chart.Unit</span>
<span class="kw">import </span><span class="dt">Chart.Types</span>
<span class="kw">import </span><span class="dt">Chart.Range</span>
<span class="kw">import </span><span class="dt">Data.Default</span>
<span class="kw">import </span><span class="dt">Diagrams.Prelude</span></code></pre></div>
<h2 id="command-line">command line</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Opts</span> <span class="fu">=</span> <span class="dt">Opts</span>
  {<span class="ot"> runs ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>    <span class="co">-- &lt;?&gt; &quot;number of runs&quot;</span>
  ,<span class="ot"> sumTo ::</span> [<span class="dt">Double</span>] <span class="co">-- &lt;?&gt; &quot;sum to this number&quot;</span>
  ,<span class="ot"> chartNum ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  ,<span class="ot"> truncAt ::</span> <span class="dt">Maybe</span> <span class="dt">Double</span>
  }
  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">ParseRecord</span> <span class="dt">Opts</span></code></pre></div>
<h2 id="main">main</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">  o ::</span> <span class="dt">Opts</span> <span class="ot">&lt;-</span> getRecord <span class="st">&quot;a random bit of text&quot;</span>
  <span class="kw">let</span> n <span class="fu">=</span> fromMaybe <span class="dv">10000</span> (runs o)
  <span class="kw">let</span> as <span class="fu">=</span> <span class="kw">case</span> sumTo o <span class="kw">of</span>
        [] <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>,<span class="dv">1000</span>,<span class="dv">10000</span>]
        x <span class="ot">-&gt;</span> x
  <span class="kw">let</span> trunc <span class="fu">=</span> fromMaybe <span class="dv">5</span> (truncAt o)
  <span class="kw">let</span> numChart <span class="fu">=</span> min (length as) <span class="fu">$</span> fromMaybe <span class="dv">3</span> (chartNum o)</code></pre></div>
<p>For reference, based on a 2.6G machine one cycle is = 0.38 ùõàs</p>
<p><code>tick_</code> taps the register twice to get a sense of the cost.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  onetick <span class="ot">&lt;-</span> tick_
  ticks <span class="ot">&lt;-</span> replicateM <span class="dv">10</span> tick_
  avtick <span class="ot">&lt;-</span> replicateM <span class="dv">1000000</span> tick_
  <span class="kw">let</span> average cs <span class="fu">=</span> L.fold ((<span class="fu">/</span>) <span class="fu">&lt;$&gt;</span> L.sum <span class="fu">&lt;*&gt;</span> L.genericLength) cs
  writeFile <span class="st">&quot;other/onetick.md&quot;</span> <span class="fu">$</span> code
    [ <span class="st">&quot;one tick_: &quot;</span> <span class="fu">&lt;&gt;</span> pack (show onetick) <span class="fu">&lt;&gt;</span> <span class="st">&quot; cycles&quot;</span>
    , <span class="st">&quot;next 10: &quot;</span> <span class="fu">&lt;&gt;</span> pack (show ticks)
    , <span class="st">&quot;average over 1m: &quot;</span> <span class="fu">&lt;&gt;</span>
      pack (show <span class="fu">$</span> average (fromIntegral <span class="fu">&lt;$&gt;</span> avtick)) <span class="fu">&lt;&gt;</span> <span class="st">&quot; cycles&quot;</span>
    ]</code></pre></div>
<pre><code>one tick_: 20 cycles
next 10: [14,12,48,12,14,14,14,48,12,14]
average over 1m: 20.268154 cycles</code></pre>
<p>Before we actually measure something, lets take a closer look at tick_.</p>
<p>A pattern I see on my machine are shifts by multiples of 4, which correspond to roughly the L1 <a href="http://stackoverflow.com/questions/1126529/what-is-the-cost-of-an-l1-cache-miss">cache latency</a>.</p>
<p>It pays to look at the whole distribution, and a compact way of doing that is to calculate quantiles:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="co">-- warmup 100</span>
  xs <span class="ot">&lt;-</span> replicateM <span class="dv">10000</span> tick_
  writeFile <span class="st">&quot;other/tick_.md&quot;</span> <span class="fu">$</span> code <span class="fu">$</span>
        ([<span class="st">&quot;[min, 10th, 20th, .. 90th, max]:&quot;</span>]<span class="ot"> ::</span> [<span class="dt">Text</span>]) <span class="fu">&lt;&gt;</span>
        [mconcat (sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> prec <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> deciles (fromIntegral <span class="fu">&lt;$&gt;</span> xs))]</code></pre></div>
<pre><code>[min, 10th, 20th, .. 90th, max]:
 24.0 24.7 25.3 26.0 26.6 27.2 27.7 28.3 28.9 29.5 304</code></pre>
<p>The important cycle count for most work is around the 30th to 50th percentile, where you get a clean measure, hopefully free of GC activity and cache miss-fires.</p>
<p>The quantile print of tick_ sometimes shows a 12 to 14 point jump around the 90th percential, and this is in the zone of an L2 access. Without a warmup, one or more larger values occur at the start, and often are in the zone of an L2 miss. Sometimes there's also a few large hiccoughs at around 2k cycles.</p>
<h1 id="summing">summing</h1>
<p>Let's measure something. The simplest something I could think of was summing.</p>
<p>The helper function <code>reportQuantiles</code> utilises <code>spins</code> which takes n measurements of a function application over a range of values to apply.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span><span class="ot"> f ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
      f x <span class="fu">=</span> foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span>x]
  _ <span class="ot">&lt;-</span> warmup <span class="dv">100</span>
  (cs,_) <span class="ot">&lt;-</span> spins n tick f as
  reportQuantiles cs as <span class="st">&quot;other/spin.md&quot;</span></code></pre></div>
<pre><code> 1.00e0:  560 582 584 586 589 592 595 599 605 646 3.30e5
 1.00e1:  174 176 178 180 200 211 215 247 248 254 5.46e4
 1.00e2:  122 122 123 124 126 126 126 127 149 170 4.98e3
 1.00e3:  119 120 123 127 135 145 165 166 195 208 616
 1.00e4:  119 124 128 132 135 139 145 157 181 196 272</code></pre>
<p>Each row represents summing to a certain point: 1 up to 10000, and each column is a decile: min, 10th .. 90th, max. The values in each cell are the number of cycles divided by the number of runs and the number of sumTo.</p>
<p>The first row (summing to 1) represents the cost of setting up the sum, so we're looking at about (692 - 128) = 560 cycles every run.</p>
<p>Overall, the computation looks like it's running in O(n) where n is the number of runs * nuber of sumTo. Specifically, I would write down the order at about:</p>
<pre><code>123 * o(n) + 560 * o(1)</code></pre>
<p>The exception is the 70th to 90th zone, where the number of cycles creeps up to 194 for 1k sumTo at the 90th percentile.</p>
<p>Charting the 1k sumTo:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span> xs_0 <span class="fu">=</span> fromIntegral <span class="fu">&lt;$&gt;</span> take <span class="dv">10000</span> (cs<span class="fu">!!</span>numChart) <span class="co">-- summing to 1000</span>
  <span class="kw">let</span> xs1 <span class="fu">=</span> (\x <span class="ot">-&gt;</span> min x (trunc<span class="fu">*</span>deciles xs_0 <span class="fu">!!</span> <span class="dv">5</span>)) <span class="fu">&lt;$&gt;</span> xs_0
  fileSvg <span class="st">&quot;other/spin1k.svg&quot;</span> (<span class="dv">750</span>,<span class="dv">250</span>) <span class="fu">$</span> pad <span class="fl">1.1</span> <span class="fu">$</span> histLine xs1</code></pre></div>
<div class="figure">
<img src="other/spin1k.svg" />

</div>
<p>Switching to a solo experiment gives:</p>
<pre><code>stack exec &quot;ghc&quot; -- -O2 -rtsopts examples/summing.lhs
./examples/summing +RTS -s -RTS --runs 10000 --sumTo 1000 --chart --chartName other/sum1e3.svg --truncAt 4</code></pre>
<div class="figure">
<img src="other/sum1e3.svg" />

</div>
<p>Executable complexity has changed the profile of the overall computation. Both measurements have the same value, however, up to around the 30th percentile.</p>
<h2 id="generic-vector">generic vector</h2>
<p>Using vector to sum:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span><span class="ot"> asv ::</span> [<span class="dt">V.Vector</span> <span class="dt">Double</span>] <span class="fu">=</span> (\x <span class="ot">-&gt;</span> V.generate (floor x) fromIntegral) <span class="fu">&lt;$&gt;</span> as
  <span class="kw">let</span><span class="ot"> sumv ::</span> <span class="dt">V.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
      sumv x <span class="fu">=</span> V.foldl (<span class="fu">+</span>) <span class="dv">0</span> x
  (csv,_) <span class="ot">&lt;-</span> spins n tick sumv asv
  reportQuantiles csv as <span class="st">&quot;other/vectorGen.md&quot;</span></code></pre></div>
<pre><code> 1.00e0:  21.0 29.9 30.9 31.8 33.4 34.4 35.5 36.6 37.1 37.6 5.68e5
 1.00e1:  7.40 9.01 9.16 9.21 9.26 9.33 9.46 9.50 9.54 9.58 1.45e5
 1.00e2:  6.72 6.82 6.84 6.86 6.91 6.93 6.98 11.0 11.2 11.3 1.42e4
 1.00e3:  6.53 6.55 6.74 6.92 6.93 7.31 7.60 7.61 9.06 9.07 1.50e3
 1.00e4:  6.51 6.52 6.53 6.70 6.85 7.57 8.63 9.02 9.03 10.7 3.12e3</code></pre>
<h2 id="randomizing-data">randomizing data</h2>
<p>To avoid ghc (and fusion) trickiness, it's often a good idea to use random numbers instead of simple progressions. One day, a compiler will discover <code>x(x+1)/2</code> and then we'll be in real trouble.</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  mwc <span class="ot">&lt;-</span> create
  <span class="fu">!</span>asr <span class="ot">&lt;-</span> (fmap V.fromList <span class="fu">&lt;$&gt;</span>) <span class="fu">&lt;$&gt;</span> sequence <span class="fu">$</span> (\x <span class="ot">-&gt;</span> samples x uniform mwc) <span class="fu">.</span> floor <span class="fu">&lt;$&gt;</span> as
  void <span class="fu">$</span> warmup <span class="dv">100</span>
  (csr,_) <span class="ot">&lt;-</span> spins n tick sumv asr
  reportQuantiles csr as <span class="st">&quot;other/vectorr.md&quot;</span></code></pre></div>
<pre><code> 1.00e0:  21.0 30.1 30.8 31.6 32.6 33.6 36.3 40.1 43.1 44.3 1.01e6
 1.00e1:  7.40 8.42 9.85 9.98 10.0 10.1 10.1 10.1 10.4 10.5 1.48e5
 1.00e2:  6.76 6.81 6.83 6.84 6.85 6.87 6.90 6.92 6.94 6.96 1.31e4
 1.00e3:  6.53 6.54 6.63 6.66 6.67 6.69 6.74 6.84 6.88 7.07 6.59e3
 1.00e4:  8.62 8.68 8.80 8.81 8.83 8.86 8.91 9.08 10.2 12.2 196</code></pre>
<p>Charting the 1k sumTo:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span> csr0 <span class="fu">=</span> fromIntegral <span class="fu">&lt;$&gt;</span> take <span class="dv">10000</span> (csr<span class="fu">!!</span>numChart) <span class="co">-- summing to 1000</span>
  <span class="kw">let</span> csr1 <span class="fu">=</span> (\x <span class="ot">-&gt;</span> min x (trunc<span class="fu">*</span>deciles csr0 <span class="fu">!!</span> <span class="dv">5</span>)) <span class="fu">&lt;$&gt;</span> csr0
  fileSvg <span class="st">&quot;other/vector1k.svg&quot;</span> (<span class="dv">750</span>,<span class="dv">250</span>) <span class="fu">$</span> pad <span class="fl">1.1</span> <span class="fu">$</span> histLine csr1</code></pre></div>
<div class="figure">
<img src="other/vector1k.svg" />

</div>
<h2 id="unboxed">unboxed</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="fu">!</span>asu <span class="ot">&lt;-</span> (fmap U.fromList <span class="fu">&lt;$&gt;</span>) <span class="fu">&lt;$&gt;</span> sequence <span class="fu">$</span> (\x <span class="ot">-&gt;</span> samples x uniform mwc) <span class="fu">.</span> floor <span class="fu">&lt;$&gt;</span> as
  <span class="kw">let</span><span class="ot"> sumu ::</span> <span class="dt">U.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
      sumu x <span class="fu">=</span> U.foldl (<span class="fu">+</span>) <span class="dv">0</span> x
  void <span class="fu">$</span> warmup <span class="dv">100</span>
  (csu,_) <span class="ot">&lt;-</span> spins n tick sumu asu
  reportQuantiles csu as <span class="st">&quot;other/vectoru.md&quot;</span></code></pre></div>
<pre><code> 1.00e0:  12.0 27.2 27.5 27.8 28.1 28.4 28.7 29.1 30.7 36.2 1.04e6
 1.00e1:  3.20 4.75 4.92 4.99 5.07 5.13 5.19 5.26 5.33 5.44 1.00e5
 1.00e2:  2.38 2.55 2.57 2.59 2.60 2.61 2.63 2.64 2.66 2.72 1.05e4
 1.00e3:  2.19 2.20 2.20 2.21 2.24 2.29 2.33 2.34 2.34 3.60 1.68e3
 1.00e4:  2.17 2.17 2.17 2.17 2.23 2.52 2.52 3.01 3.01 3.01 105</code></pre>
<p>Charting the 1k sumTo:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span> csu0 <span class="fu">=</span> fromIntegral <span class="fu">&lt;$&gt;</span> take <span class="dv">10000</span> (csu<span class="fu">!!</span>numChart) <span class="co">-- summing to 1000</span>
  <span class="kw">let</span> csu1 <span class="fu">=</span> (\x <span class="ot">-&gt;</span> min x (trunc<span class="fu">*</span>deciles csu0 <span class="fu">!!</span> <span class="dv">5</span>)) <span class="fu">&lt;$&gt;</span> csu0
  fileSvg <span class="st">&quot;other/vectoru1k.svg&quot;</span> (<span class="dv">750</span>,<span class="dv">250</span>) <span class="fu">$</span> pad <span class="fl">1.1</span> <span class="fu">$</span> histLine csu1</code></pre></div>
<div class="figure">
<img src="other/vectoru1k.svg" />

</div>
<h2 id="storable">storable</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="fu">!</span>ass <span class="ot">&lt;-</span> (fmap S.fromList <span class="fu">&lt;$&gt;</span>) <span class="fu">&lt;$&gt;</span> sequence <span class="fu">$</span> (\x <span class="ot">-&gt;</span> samples x uniform mwc) <span class="fu">.</span> floor <span class="fu">&lt;$&gt;</span> as
  <span class="kw">let</span><span class="ot"> sums ::</span> <span class="dt">S.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
      sums x <span class="fu">=</span> S.foldl (<span class="fu">+</span>) <span class="dv">0</span> x
  void <span class="fu">$</span> warmup <span class="dv">100</span>
  (css,_) <span class="ot">&lt;-</span> spins n tick sums ass
  reportQuantiles css as <span class="st">&quot;other/vectors.md&quot;</span></code></pre></div>
<pre><code> 1.00e0:  12.0 25.4 25.9 26.4 26.9 27.4 27.8 28.3 28.7 30.8 1.06e6
 1.00e1:  3.00 3.57 3.69 3.82 4.26 4.38 4.47 4.55 4.62 4.69 1.01e5
 1.00e2:  2.38 2.47 2.53 2.54 2.56 2.57 2.71 2.74 2.76 2.79 1.04e4
 1.00e3:  2.19 2.20 2.20 2.20 2.20 2.31 2.40 3.20 3.60 3.60 948
 1.00e4:  2.17 2.17 2.17 2.23 2.30 2.52 2.58 3.01 3.01 3.55 111</code></pre>
<p>Charting the 1k sumTo:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  <span class="kw">let</span> css0 <span class="fu">=</span> fromIntegral <span class="fu">&lt;$&gt;</span> take <span class="dv">10000</span> (css<span class="fu">!!</span>numChart) <span class="co">-- summing to 1000</span>
  <span class="kw">let</span> css1 <span class="fu">=</span> (\x <span class="ot">-&gt;</span> min x (trunc<span class="fu">*</span>deciles css0 <span class="fu">!!</span> <span class="dv">5</span>)) <span class="fu">&lt;$&gt;</span> css0
  fileSvg <span class="st">&quot;other/vectors1k.svg&quot;</span> (<span class="dv">750</span>,<span class="dv">250</span>) <span class="fu">$</span> pad <span class="fl">1.1</span> <span class="fu">$</span> histLine css1</code></pre></div>
<div class="figure">
<img src="other/vectors1k.svg" />

</div>
<h2 id="tickf-ticka-tickfa">tickf, ticka, tickfa</h2>
<p>These functions attempt to discriminate between cycles used to compute <code>f a</code> (ie to apply the function f), and cycles used to force <code>a</code>. In experiments so far, this act of observation tends to change the number of cycles.</p>
<p>Separation of the <code>f</code> and <code>a</code> effects in <code>f a</code></p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  void <span class="fu">$</span> warmup <span class="dv">100</span>
  (csr2,_) <span class="ot">&lt;-</span> spins n tick sumv asr
  (csvf,_) <span class="ot">&lt;-</span> spins n tickf sumv asr
  (csva,_) <span class="ot">&lt;-</span> spins n ticka sumv asr
  (csvfa,_) <span class="ot">&lt;-</span> spins n tickfa sumv asr
  reportQuantiles csr2 as <span class="st">&quot;other/vectorr2.md&quot;</span>
  reportQuantiles csvf as <span class="st">&quot;other/vectorf.md&quot;</span>
  reportQuantiles csva as <span class="st">&quot;other/vectora.md&quot;</span>
  reportQuantiles (fmap fst <span class="fu">&lt;$&gt;</span> csvfa) as <span class="st">&quot;other/vectorfaf.md&quot;</span>
  reportQuantiles (fmap snd <span class="fu">&lt;$&gt;</span> csvfa) as <span class="st">&quot;other/vectorfaa.md&quot;</span></code></pre></div>
<p>a full tick</p>
<pre><code> 1.00e0:  21.0 29.8 32.5 33.0 33.4 33.8 34.1 35.5 36.9 40.2 6.21e5
 1.00e1:  7.20 8.81 9.08 9.19 9.43 9.55 9.66 9.77 9.88 10.0 1.25e5
 1.00e2:  6.74 6.81 6.82 6.85 6.90 6.94 7.14 7.43 7.47 7.54 1.37e4
 1.00e3:  6.53 6.55 6.73 6.92 7.30 7.59 9.05 9.05 9.08 10.7 1.41e3
 1.00e4:  6.51 6.51 6.52 6.52 6.66 7.23 8.03 9.02 9.03 9.08 238</code></pre>
<p>just function application</p>
<pre><code> 1.00e0:  12.0 28.1 29.3 29.9 30.6 31.2 31.9 32.5 37.0 38.1 1.35e6
 1.00e1:  6.40 7.98 8.09 8.15 8.20 8.25 8.30 8.49 8.94 9.13 1.33e5
 1.00e2:  6.66 6.81 6.82 6.83 6.84 6.87 6.90 6.91 6.94 6.98 1.36e4
 1.00e3:  6.52 6.53 6.54 6.54 6.55 6.70 6.74 9.05 9.06 9.39 1.42e3
 1.00e4:  6.51 6.51 6.52 6.52 6.53 6.71 7.20 8.52 9.03 9.06 150</code></pre>
<p>just forcing <code>a</code>:</p>
<pre><code> 1.00e0:  12.0 12.9 13.4 13.8 14.2 14.6 15.7 21.7 24.7 47.5 306
 1.00e1:  1.20 1.42 1.76 2.05 2.07 2.09 2.12 2.14 2.44 2.61 7.60
 1.00e2:  0.120 0.129 0.136 0.143 0.150 0.208 0.214 0.219 0.224 0.229 0.740
 1.00e3:  0.0120 0.0136 0.0154 0.0198 0.0216 0.0219 0.0222 0.0225 0.0228 0.0280 0.200
 1.00e4:  0.00120 0.00525 0.00703 0.00759 0.00800 0.00836 0.00868 0.00913 0.00984 0.0109 0.0684</code></pre>
<p>the f splice of f a</p>
<pre><code> 1.00e0:  14.0 17.8 18.8 19.4 19.8 20.2 20.6 22.1 53.2 54.2 1.39e6
 1.00e1:  5.00 5.65 7.52 8.91 8.97 9.02 9.07 9.14 9.21 9.29 1.54e5
 1.00e2:  6.72 6.78 6.92 7.10 7.11 7.12 7.13 7.14 7.15 7.17 1.72e4
 1.00e3:  6.69 6.70 6.73 6.73 6.74 6.74 6.76 6.92 6.92 6.93 1.97e3
 1.00e4:  6.51 6.51 6.52 6.52 6.70 6.71 6.91 7.57 9.02 9.04 226</code></pre>
<p>the a slice of fa</p>
<pre><code> 1.00e0:  12.0 13.0 13.3 13.6 13.9 14.2 14.5 14.8 35.7 48.0 390
 1.00e1:  1.20 1.27 1.32 1.35 1.38 1.42 1.45 1.48 3.12 4.79 9.60
 1.00e2:  0.120 0.128 0.132 0.136 0.139 0.142 0.146 0.149 0.350 0.479 11.1
 1.00e3:  0.0120 0.0132 0.0137 0.0143 0.0148 0.0174 0.0204 0.0215 0.0229 0.0475 0.300
 1.00e4:  0.00120 0.00592 0.00679 0.00723 0.00757 0.00782 0.00819 0.00869 0.00957 0.0107 0.142</code></pre>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell">  pure ()</code></pre></div>
<h2 id="helpers">helpers</h2>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">showxs ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>
showxs qs m <span class="fu">=</span>
          sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> Formatting.expt <span class="dv">2</span>) m <span class="fu">&lt;&gt;</span> <span class="st">&quot;: &quot;</span> <span class="fu">&lt;&gt;</span>
          mconcat (sformat (<span class="st">&quot; &quot;</span> <span class="fu">%</span> prec <span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> ((<span class="fu">/</span>m) <span class="fu">&lt;$&gt;</span> qs))

<span class="ot">deciles ::</span> forall (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="fu">.</span> <span class="dt">Foldable</span> f <span class="ot">=&gt;</span> f <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>]
deciles xs <span class="fu">=</span>
  (\x <span class="ot">-&gt;</span> fromMaybe <span class="dv">0</span> <span class="fu">$</span> quantile x (tdigest<span class="ot"> xs ::</span> <span class="dt">TDigest</span> <span class="dv">25</span>)) <span class="fu">&lt;$&gt;</span> ((<span class="fl">0.1</span><span class="fu">*</span>) <span class="fu">&lt;$&gt;</span> [<span class="dv">0</span><span class="fu">..</span><span class="dv">10</span>])

<span class="ot">reportQuantiles ::</span>  [[<span class="dt">Cycles</span>]] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
reportQuantiles css as name <span class="fu">=</span>
  writeFile name <span class="fu">$</span> code <span class="fu">$</span> zipWith showxs (deciles <span class="fu">.</span> fmap fromIntegral <span class="fu">&lt;$&gt;</span> css) as

<span class="ot">code ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Text</span>
code cs <span class="fu">=</span> <span class="st">&quot;\n~~~\n&quot;</span> <span class="fu">&lt;&gt;</span> intercalate <span class="st">&quot;\n&quot;</span> cs <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n~~~\n&quot;</span>

<span class="ot">histLine ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Chart&#39;</span> a
histLine xs <span class="fu">=</span>
    line (repeat (<span class="dt">LineConfig</span> <span class="fl">0.002</span> (<span class="dt">Color</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">1</span> <span class="fl">0.1</span>))) wideScreen
     (zipWith (\x y <span class="ot">-&gt;</span> [<span class="dt">V2</span> x <span class="dv">0</span>,<span class="dt">V2</span> x y]) [<span class="dv">0</span><span class="fu">..</span>] xs) <span class="fu">&lt;&gt;</span>
        axes def wideScreen
        [ toCorners (<span class="dt">V2</span>
         (<span class="dt">Range</span> (<span class="fl">0.0</span>,fromIntegral <span class="fu">$</span> length xs))
         (<span class="dt">Range</span> (<span class="dv">0</span>,L.fold (<span class="dt">L.Fold</span> max <span class="dv">0</span> identity) xs)))]</code></pre></div>
<h1 id="notes">notes</h1>
<h2 id="rdpmc">rdpmc</h2>
<p>A first-cousin of rdtsc, <a href="https://software.intel.com/en-us/forums/software-tuning-performance-optimization-platform-monitoring/topic/595214">rdpmc</a>, offers the possibility to track page faults, cache misses and other such beasties, but lacks an easy entry-point c library.</p>
<h2 id="workflow">workflow</h2>
<pre><code>stack build --copy-bins --exec &quot;perf-examples&quot; --exec &quot;pandoc -f markdown+lhs -t html -i examples/examples.lhs -o index.html --filter pandoc-include&quot; --exec &quot;pandoc -f markdown+lhs -t markdown -i examples/examples.lhs -o readme.md --filter pandoc-include&quot;</code></pre>
<h2 id="time-performance-references">time performance references</h2>
<p><a href="http://neilmitchell.blogspot.co.uk/2014/01/optimising-haskell-for-tight-inner-loop.html">Optimising haskell for a tight inner loop</a></p>
<p><a href="http://stackoverflow.com/questions/3276240/tools-for-analyzing-performance-of-a-haskell-program/3276557#3276557">Tools for analysing performance</a></p>
<p><a href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/">Write haskell as fast as c</a></p>
<p><a href="http://stackoverflow.com/questions/6121146/reading-ghc-core">Reading ghc core</a></p>
<h2 id="space-performance-references">space performance references</h2>
<p><a href="http://neilmitchell.blogspot.com.au/2013/02/chasing-space-leak-in-shake.html">Chasing space leaks in shake</a></p>
<p><a href="http://blog.ezyang.com/2011/05/space-leak-zoo/">Space leak zoo</a></p>
<p><a href="http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/">Anatomy of a thunk leak</a></p>
<p><a href="http://blog.ezyang.com/2011/05/an-insufficiently-lazy-map/">An insufficiently lazy map</a></p>
<p><a href="http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/">Pinpointing space leaks in big programs</a></p>
<h2 id="a-fairly-old-checklist">A (fairly old) checklist</h2>
<ol class="incremental" style="list-style-type: decimal">
<li>compile with rtsopts flag</li>
</ol>
<pre><code>find . -name &#39;*.o&#39; -type f -print -delete
find . -name &#39;*.hl&#39; -type f -print -delete
ghc -O2 --make example/example.hs -fforce-recomp -isrc:example -rtsopts</code></pre>
<ol class="incremental" start="2" style="list-style-type: decimal">
<li><p>check GC <code>example +RTS -s</code></p></li>
<li><p>enabling profiling</p></li>
</ol>
<ul class="incremental">
<li>a normal ghc <code>ghc -fforce-recomp --make -O2 -isrc example/example.hs</code></li>
<li>profile enabled automatically <code>ghc -prof -auto -auto-all -fforce-recomp --make -O2 -isrc:dev A.hs</code></li>
<li>if template haskell <code>ghc -osuf p_o -prof -auto -auto-all -fforce-recomp --make -O2 -isrc:dev A.hs</code></li>
</ul>
<ol class="incremental" start="4" style="list-style-type: decimal">
<li><p>create an A.prof on execution: <code>time A +RTS -p</code></p></li>
<li><p>space</p></li>
</ol>
<pre><code>  time dev/Reuters/A &quot;test/data/reuters-100k.txt&quot; +RTS -p -hc
  hp2ps -e8in -c A.hp</code></pre>
<pre><code>hy = types
hd = constructors</code></pre>
<ol class="incremental" start="6" style="list-style-type: decimal">
<li><p>strictness pragmas?</p></li>
<li><p>space leaks</p></li>
</ol>
<pre><code>+RTS -s - additional memory
+RTS -xt -hy</code></pre>
<h2 id="cache-cycle-estimates">cache cycle estimates</h2>
<p>register | 4 per cycle |<br />
L1 Cache access| 3-4 cycles|<br />
L2 Cache access| 11-12 cycles|<br />
L3 unified access| 30 - 40|<br />
DRAM hit| 195 cycles|<br />
L1 miss | 40 cycles|<br />
L2 miss | &gt;600 cycles|</p>
